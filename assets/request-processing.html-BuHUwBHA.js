import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as r,d as e,e as n,b as o,w as i,r as d,o as u}from"./app-C8JBMu7V.js";const p={};function m(g,t){const l=d("RouteLink");return u(),a("div",null,[t[18]||(t[18]=r('<h1 id="请求处理流程" tabindex="-1"><a class="header-anchor" href="#请求处理流程"><span>请求处理流程</span></a></h1><h2 id="请先读我" tabindex="-1"><a class="header-anchor" href="#请先读我"><span>请先读我</span></a></h2><div class="hint-container tip"><p class="hint-container-title">在 <code>Xtream</code> 中，如何 <strong>处理</strong> 请求并没有强制的规定</p><p>请求由谁来处理？如何处理？ 已经内置了一套注解。</p></div><p>一般的请求处理流程大概涉及到下面几个方面：</p>',4)),e("ol",null,[e("li",null,[t[9]||(t[9]=n("报文解析 ")),e("ul",null,[t[7]||(t[7]=e("li",null,"收到的报文是字节流，不方便处理，往往都会将其抽象为一个请求对象。",-1)),t[8]||(t[8]=e("li",null,[n("在 "),e("strong",null,"Xtream"),n(" 中，"),e("code",null,"XtreamRequest"),n(" 就是一个请求对象，它封装了原始的请求报文。")],-1)),e("li",null,[t[1]||(t[1]=n("在 ")),t[2]||(t[2]=e("strong",null,"JT/T 808",-1)),t[3]||(t[3]=n(" 的实现中，将 ")),t[4]||(t[4]=e("code",null,"XtreamRequest",-1)),t[5]||(t[5]=n(" 进一步抽象为 ")),o(l,{to:"/ext/jt/jt808/quick-start/terminology.html#jt808request"},{default:i(()=>t[0]||(t[0]=[n("Jt808Request")])),_:1,__:[0]}),t[6]||(t[6]=n("，新增了几个方法。"))])])]),t[10]||(t[10]=r("<li>请求路由 <ul><li>上面提到的 <code>XtreamRequest</code> 到底由哪个处理器来处理呢？</li><li>内置了基于 <code>@Jt808RequestHandlerMapping</code> 注解的处理器</li></ul></li><li>业务处理 <ul><li>请求已经被路由到了具体的处理器，接下来如何处理，就看你的业务逻辑了。不再赘述。</li></ul></li><li>响应(可选) <ul><li>内置了 <code>@Jt808ResponseBody</code> 注解，用于将业务处理结果编码为 <strong>JT/T 808</strong> 格式的报文。</li><li>当然也可以不响应，直接返回 <code>void / Mono.empty()</code> 即可。</li></ul></li><li>异常处理 <ul><li>业务处理过程中，如果出现了异常，如何处理？</li><li>内置了: <code>XtreamRequestExceptionHandler</code> 来统一处理异常</li></ul></li>",4))]),t[19]||(t[19]=e("p",null,"对于上述请求处理流程，有如下两种处理方式：",-1)),t[20]||(t[20]=e("h2",{id:"_1-基于内置注解",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-基于内置注解"},[e("span",null,"1. 基于内置注解")])],-1)),e("p",null,[t[12]||(t[12]=e("strong",null,"Xtream",-1)),t[13]||(t[13]=n(" 对 ")),t[14]||(t[14]=e("strong",null,"JT/T 808",-1)),t[15]||(t[15]=n(" 消息的处理提供了一套注解，详情见 ")),o(l,{to:"/ext/jt/jt808/annotation-driven/overview.html"},{default:i(()=>t[11]||(t[11]=[n("注解驱动开发")])),_:1,__:[11]})]),t[21]||(t[21]=e("h2",{id:"_2-自定义处理器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-自定义处理器"},[e("span",null,"2. 自定义处理器")])],-1)),e("p",null,[t[17]||(t[17]=n("你可以扩展自己的请求处理器，详情见 ")),o(l,{to:"/ext/jt/jt808/customization/request-handler.html"},{default:i(()=>t[16]||(t[16]=[n("自定义请求处理器")])),_:1,__:[16]})])])}const c=s(p,[["render",m]]),X=JSON.parse('{"path":"/ext/jt/jt808/quick-start/request-processing.html","title":"请求处理流程","lang":"zh-CN","frontmatter":{"icon":"arrow-right-arrow-left","article":false,"description":"请求处理流程 请先读我 在 Xtream 中，如何 处理 请求并没有强制的规定 请求由谁来处理？如何处理？ 已经内置了一套注解。 一般的请求处理流程大概涉及到下面几个方面： 报文解析 收到的报文是字节流，不方便处理，往往都会将其抽象为一个请求对象。 在 Xtream 中，XtreamRequest 就是一个请求对象，它封装了原始的请求报文。 在 JT/...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"请求处理流程\\",\\"description\\":\\"请求处理流程 请先读我 在 Xtream 中，如何 处理 请求并没有强制的规定 请求由谁来处理？如何处理？ 已经内置了一套注解。 一般的请求处理流程大概涉及到下面几个方面： 报文解析 收到的报文是字节流，不方便处理，往往都会将其抽象为一个请求对象。 在 Xtream 中，XtreamRequest 就是一个请求对象，它封装了原始的请求报文。 在 JT/...\\"}"],["meta",{"property":"og:url","content":"https://hylexus.github.io/xtream-codec/ext/jt/jt808/quick-start/request-processing.html"}],["meta",{"property":"og:site_name","content":"xtream-codec"}],["meta",{"property":"og:title","content":"请求处理流程"}],["meta",{"property":"og:description","content":"请求处理流程 请先读我 在 Xtream 中，如何 处理 请求并没有强制的规定 请求由谁来处理？如何处理？ 已经内置了一套注解。 一般的请求处理流程大概涉及到下面几个方面： 报文解析 收到的报文是字节流，不方便处理，往往都会将其抽象为一个请求对象。 在 Xtream 中，XtreamRequest 就是一个请求对象，它封装了原始的请求报文。 在 JT/..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-17T15:13:15.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-17T15:13:15.000Z"}]]},"git":{"createdTime":1734436871000,"updatedTime":1734448395000,"contributors":[{"name":"hylexus","username":"","email":"hylexus@163.com","commits":2}]},"readingTime":{"minutes":1.33,"words":399},"filePathRelative":"ext/jt/jt808/quick-start/request-processing.md","excerpt":"\\n<h2>请先读我</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">在 <code>Xtream</code> 中，如何 <strong>处理</strong> 请求并没有强制的规定</p>\\n<p>请求由谁来处理？如何处理？ 已经内置了一套注解。</p>\\n</div>\\n<p>一般的请求处理流程大概涉及到下面几个方面：</p>\\n<ol>\\n<li>报文解析\\n<ul>\\n<li>收到的报文是字节流，不方便处理，往往都会将其抽象为一个请求对象。</li>\\n<li>在 <strong>Xtream</strong> 中，<code>XtreamRequest</code> 就是一个请求对象，它封装了原始的请求报文。</li>\\n<li>在 <strong>JT/T 808</strong> 的实现中，将 <code>XtreamRequest</code> 进一步抽象为 <a href=\\"/xtream-codec/ext/jt/jt808/quick-start/terminology.html#jt808request\\" target=\\"_blank\\">Jt808Request</a>，新增了几个方法。</li>\\n</ul>\\n</li>\\n<li>请求路由\\n<ul>\\n<li>上面提到的 <code>XtreamRequest</code> 到底由哪个处理器来处理呢？</li>\\n<li>内置了基于 <code>@Jt808RequestHandlerMapping</code> 注解的处理器</li>\\n</ul>\\n</li>\\n<li>业务处理\\n<ul>\\n<li>请求已经被路由到了具体的处理器，接下来如何处理，就看你的业务逻辑了。不再赘述。</li>\\n</ul>\\n</li>\\n<li>响应(可选)\\n<ul>\\n<li>内置了 <code>@Jt808ResponseBody</code> 注解，用于将业务处理结果编码为 <strong>JT/T 808</strong> 格式的报文。</li>\\n<li>当然也可以不响应，直接返回 <code>void / Mono.empty()</code> 即可。</li>\\n</ul>\\n</li>\\n<li>异常处理\\n<ul>\\n<li>业务处理过程中，如果出现了异常，如何处理？</li>\\n<li>内置了: <code>XtreamRequestExceptionHandler</code> 来统一处理异常</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{c as comp,X as data};
